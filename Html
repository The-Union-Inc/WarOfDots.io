<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Dot Conquest IO</title>
<style>
    html,body{
        margin:0;
        padding:0;
        overflow:hidden;
        background:#111;
        font-family:sans-serif;
    }
    canvas{
        display:block;
    }
    #ui{
        position:absolute;
        top:10px;
        left:10px;
        color:white;
        z-index:10;
    }
</style>
</head>
<body>
<div id="ui">Drag to select units • Tap to move • Capture bases</div>
<canvas id="game"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

function resize(){
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
resize();
window.addEventListener("resize", resize);

class Unit{
    constructor(x,y,team){
        this.x=x;
        this.y=y;
        this.team=team;
        this.radius=6;
        this.speed=1.2;
        this.target=null;
        this.selected=false;
        this.hp=100;
    }
    update(){
        if(this.target){
            let dx=this.target.x-this.x;
            let dy=this.target.y-this.y;
            let dist=Math.hypot(dx,dy);
            if(dist>2){
                this.x+=dx/dist*this.speed;
                this.y+=dy/dist*this.speed;
            }
        }
    }
    draw(){
        ctx.beginPath();
        ctx.arc(this.x,this.y,this.radius,0,Math.PI*2);
        ctx.fillStyle=this.team==="player"?"#4da6ff":"#ff4d4d";
        ctx.fill();
        if(this.selected){
            ctx.strokeStyle="#fff";
            ctx.stroke();
        }
    }
}

class Base{
    constructor(x,y){
        this.x=x;
        this.y=y;
        this.radius=30;
        this.owner=null;
        this.capture=0;
    }
    update(){
        let playerCount=units.filter(u=>u.team==="player" && dist(u,this)<this.radius).length;
        let enemyCount=units.filter(u=>u.team==="enemy" && dist(u,this)<this.radius).length;

        if(playerCount>enemyCount){
            this.capture+=0.01;
            if(this.capture>=1){
                this.owner="player";
            }
        }else if(enemyCount>playerCount){
            this.capture-=0.01;
            if(this.capture<=-1){
                this.owner="enemy";
            }
        }
    }
    draw(){
        ctx.beginPath();
        ctx.arc(this.x,this.y,this.radius,0,Math.PI*2);
        ctx.fillStyle=this.owner==="player"?"#0044aa":
                     this.owner==="enemy"?"#aa0000":"#444";
        ctx.fill();

        ctx.fillStyle="white";
        ctx.fillRect(this.x-20,this.y-40,40,5);
        ctx.fillStyle="#4da6ff";
        ctx.fillRect(this.x-20,this.y-40,40*(this.capture+1)/2,5);
    }
}

function dist(a,b){
    return Math.hypot(a.x-b.x,a.y-b.y);
}

let units=[];
let bases=[];

for(let i=0;i<15;i++){
    units.push(new Unit(100+Math.random()*100,200+Math.random()*200,"player"));
    units.push(new Unit(canvas.width-100+Math.random()*50,200+Math.random()*200,"enemy"));
}

bases.push(new Base(canvas.width/2,canvas.height/2));
bases.push(new Base(canvas.width/2,canvas.height/4));
bases.push(new Base(canvas.width/2,canvas.height*0.75));

let selecting=false;
let selectStart={x:0,y:0};

canvas.addEventListener("mousedown",startSelect);
canvas.addEventListener("touchstart",e=>startSelect(e.touches[0]));

canvas.addEventListener("mousemove",moveSelect);
canvas.addEventListener("touchmove",e=>{
    moveSelect(e.touches[0]);
    e.preventDefault();
},{passive:false});

canvas.addEventListener("mouseup",endSelect);
canvas.addEventListener("touchend",endSelect);

function startSelect(e){
    selecting=true;
    selectStart.x=e.clientX;
    selectStart.y=e.clientY;
}

function moveSelect(e){
    if(!selecting)return;
}

function endSelect(e){
    if(!selecting)return;
    selecting=false;

    let endX=e.changedTouches?e.changedTouches[0].clientX:e.clientX;
    let endY=e.changedTouches?e.changedTouches[0].clientY:e.clientY;

    let dx=Math.abs(endX-selectStart.x);
    let dy=Math.abs(endY-selectStart.y);

    if(dx<5 && dy<5){
        units.filter(u=>u.selected).forEach(u=>{
            u.target={x:endX,y:endY};
        });
    }else{
        units.forEach(u=>{
            u.selected=
                u.team==="player" &&
                u.x>Math.min(selectStart.x,endX) &&
                u.x<Math.max(selectStart.x,endX) &&
                u.y>Math.min(selectStart.y,endY) &&
                u.y<Math.max(selectStart.y,endY);
        });
    }
}

function enemyAI(){
    units.filter(u=>u.team==="enemy").forEach(u=>{
        if(!u.target || Math.random()<0.01){
            let targetBase=bases[Math.floor(Math.random()*bases.length)];
            u.target={x:targetBase.x,y:targetBase.y};
        }
    });
}

function combat(){
    for(let a of units){
        for(let b of units){
            if(a!==b && a.team!==b.team && dist(a,b)<8){
                a.hp-=0.5;
                b.hp-=0.5;
            }
        }
    }
    units=units.filter(u=>u.hp>0);
}

function gameLoop(){
    ctx.clearRect(0,0,canvas.width,canvas.height);

    bases.forEach(b=>{
        b.update();
        b.draw();
    });

    units.forEach(u=>{
        u.update();
        u.draw();
    });

    enemyAI();
    combat();

    requestAnimationFrame(gameLoop);
}

gameLoop();
</script>
</body>
</html>
